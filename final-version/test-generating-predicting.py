def cleanSeq(x, cod_type):
  if cod_type==2:
    # first row correction
    notePos = np.where(x[0,:]==1)[0]        # where are the ones
    notePosWrong = np.array([aa%2 for aa in notePos])  
    notePosWrongPos = np.where(notePosWrong==1)[0]     # we look if corespond to odd positions
    x[0,notePos[notePosWrongPos]]=0                    # if present, we correct to 0 the odd
    x[0,notePos[notePosWrongPos]-1]=1                  # if present, we correct to 0 the correspondent even position
    
    # other rows correction
    # when we have 1 in even and odd position, then remove the second one 
    x[:,[ii for ii in range(x.shape[1]) if ii%2==1 ] ] = x[:,[ii for ii in range(x.shape[1]) if ii%2==1 ] ] * (1-x)[:,[ii for ii in range(x.shape[1]) if ii%2==0 ] ]

    # now we want to compare with previous row
    x_0 = x[1:,1:]     #   base values to correct
    x_1 = x[0:-1,1:]   #   previous same column
    x_11 = x[0:-1,0:-1]#   previous even column
    x_sel = np.zeros(x_0.shape)  # odd columns f x
    x_sel[:, [ii for ii in range(x_sel.shape[1]) if ii%2==0 ] ] =1   # corespond to even columns of x_sel
    x_2 = ((x_1==0) & (x_11==0) & (x_0==1) & (x_sel==1))   # columns with one in odd that not have any in even or odd correspondece in previous row
    x[1:,1:][x_2] = 0    # correction in unpair row
    x[1:,:-1][x_2] = 1
    
  return(x)


def create_midi(prediction_output, qnsf = 4, cod_type=2, midiOutputFile='test_output.mid'):
    """ convert the output from the prediction to notes and create a midi file
        from the notes """
    offset = 0
    output_notes = []

    # create note and chord objects based on the values generated by the model
    for i,pattern in enumerate(prediction_output):
      # pattern is a note
      notes = []
      noteIndex = np.where(pattern==1)[0]
      noteIndex = noteIndex[[ii % cod_type ==0 for ii in noteIndex]]
      if len(noteIndex)>0:  
        for current_note in noteIndex:
          new_note = note.Note(int(current_note/cod_type + 21))
          new_note.storedInstrument = instrument.Piano()
          new_note.offset = offset
          # duration.quarterLength in case cod_type==2
          if cod_type==2 :
            # sequence of duration equal to one in the odd position
            auxDuration = np.where(prediction_output[(i+1):,current_note + 1]==1)[0]
            # initialize duration
            minimum_value = 0
            if len(auxDuration)>0:
              # minimum position where we have a consecuive sequence at 0
              # we add one to include complete sequences
              minimum_value = np.array(range(len(auxDuration)+1))[~np.isin(range(len(auxDuration)+1),auxDuration)].min()

            # we calcuate the minimum number in the sequance :len(auxDuration) that is not 
            # in the sequence, add one and divide by QNSF
            new_note.duration.quarterLength = ( minimum_value + 1.0)/qnsf
            
          output_notes.append(new_note)

      offset += 1.0/qnsf
    
    midi_stream = stream.Stream(output_notes)

    midi_stream.write('midi', fp=midiOutputFile)
    print("created midi file: ",midiOutputFile )
    
    ##############    TODO #################

def generateSeq2seq(x, y, model ,pred_seq=1):
  z= x.to(device)
  w= y.to(device)
  x1shape = x.shape[1]
  pred_shape=list(x.shape[1:])
  pred_shape[0] += pred_seq*pred_shape[0]
  pred_test=np.zeros(pred_shape)
  pred_test[0:x1shape,:] = x[0,:,:].numpy()                # we take the firdt samples from x 
  for i in range(pred_seq):                                # predicting 
    y_pred = model.eval()(z,w,0)     #teacher forcing set to 0 during validation
    y_pred_pos=(y_pred[0,:,:].cpu().detach().numpy()>0)
    for ii in range(len(y_pred_pos)):
      pred_test[x1shape + ii,y_pred_pos[ii]] = 1.0
  return pred_test
  
  # generated length
PRED_SEQ = 1    #   !!!!  do not change it
dataset_test2=MidiDataset(qnsf=QNSF, seq_len=SEQ_LEN, cod_type=COD_TYPE, midi_files=['Classical-Piano-Composer/midi_songs/Gold_Silver_Rival_Battle.mid'])


# we recover one song for the first sequence
pred_generator = data.DataLoader(dataset_train, batch_size=1, shuffle=False)
# pred

# transform to input tensor last batch
for i,batch in enumerate(pred_generator):
  xinit = batch[0][0:1,:,:]
  yinit = batch[1][0:1,:,:]
  break

print(xinit.shape)
print(yinit.shape)

y_pred = seq2seqMod.eval()(xinit.to(device),yinit.to(device),0)


'''

pred_test = generateSeq2seq(xinit,yinit,seq2seqMod,pred_seq=PRED_SEQ)
print(pred_test.shape)
if COD_TYPE==2:
  pred_test_clean = cleanSeq(pred_test, cod_type=COD_TYPE)
else:
  pred_test_clean = pred_test
print(pred_test_clean.shape)
create_midi(pred_test_clean, qnsf = QNSF, cod_type=COD_TYPE, midiOutputFile='test_seq2seqv2_006.mid')

'''

pred_test = generateSeq2seq(xinit,yinit,seq2seqMod,pred_seq=PRED_SEQ)

create_midi(pred_test, qnsf = QNSF, cod_type=COD_TYPE, midiOutputFile='test_seq2seqv2_004.mid')
